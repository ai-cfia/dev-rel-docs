# Python: Handling and Raising Exception

|:wave: To know more / Pour en savoir plus (anglais seulement)|
|:--|
|[Python's raise: Effectively Raising Exceptions in Your Code](https://realpython.com/python-raise-exception/#chaining-exceptions-with-the-from-clause)|
| [Python Exceptions: An Introduction](https://realpython.com/python-exceptions/)|
|[How to Catch Multiple Exceptions in Python](https://realpython.com/python-catch-multiple-exceptions/)|
|[Ever Better Error Messages](https://realpython.com/python312-error-messages/)|
|[LBYL vs EAFP: Preventing or Handling Errors in Python](https://realpython.com/python-lbyl-vs-eafp/)|
|[Following Best Practices When Raising Exceptions](https://realpython.com/python-raise-exception/#following-best-practices-when-raising-exceptions)|
|[Take the test](https://realpython.com/quizzes/python-raise-exception/)|

## Summary

|Chapters|Chapitres|
|--|--|
|[What is an Exception](#what-is-an-exception)| [Qu'est-ce qu'une Exception](#quest-ce-quune-exception)|
|[Different ways of handling an Exception](#different-ways-of-handling-an-exception)| [Différentes façon de gérer une Exception](#différente-façon-de-gérer-une-exception)|
|[Different ways of raising an Exception](#different-ways-of-raising-an-exception)| [Différentes façon de lever une Exception](#différente-façon-de-lever-une-exception)|
|[Good practice when handling/raising Exceptions](#good-practice-when-handlingraising-exceptions)|[Les bonnes pratiques lorsqu'on lève / gère des Exceptions](#les-bonnes-pratiques-lorsquon-lève--gère-des-exceptions)|
|[Annexe](#annexe-1)|[Annexe](#annexe-1)|

## Before starting

- [Version Française](#avant-de-commencer) :small_blue_diamond:
- This training is aimed at the backend developer, but everybody is welcome to
  read it.

### What is an Exception

An Exception in Python indicates that something went wrong in your code. It can take
the form of either an error (classic case), a warning, or an exceptional situation.

> :grey_exclamation: Note that not all exceptions in Python are errors. The best
example is the
[`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration)
object which is a subclass of `Exception`

When an `Exception` represents an error, it is common standard to add the
`Error` suffix to its name. Example:

- `ValueError`, `DivisionByZeroError`, etc.

When the exception is supposed to be a `Warning`, Python offers the class `Warning`
to raise the flag on conditions that don't need to terminate the program.

There are two kinds of exceptions in Python:

- Built-in exceptions: Those exceptions are built into the language.
- User-defined exceptions: Custom exceptions defined by the developers. They are
typically in a module for a specific project

> You can find the built-in exception hierarchy [here](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

#### Creating a custom Exception example

```python
# Always use Exception for your code
# Do not use BaseException
class MyException(Exception):
    pass

# For examples see error link
class MyExceptionError(Exception):
    pass

# UserWarning is for warning generated by user code
# Warning is the base class for warning categories
class MyWarning(UserWarning):
    pass
```

> In Python, it is common practice to create a placeholder class for exceptions
with the keyword pass as the most important feature of the class is its name.

|:warning:| In Python, a good custom exception name communicates the underlying issue|
|--|:--|
|:x:| GenericException(Exception)|
|:white_check_mark:| SpecificToProjectException(Exception)|

Here is a list of the principal exception's attributes:

|Attributes|Type|Actions|
|--|--|--|
|`args`|`tuple` or `str`|Contain all the value pass at the class at instanciation|
|`__traceback__`|dunder attribute|hold the traceback object of the exception|
|`__cause__`|dunder attribute|store the expression passed to the `from` keyword|
|`.with_traceback()`|methods|Update the exception's traceback object|
|`.add_notes()`|methods|Add notes to the exception traceback. (`__note__`)|

When you instantiate an `Exception`, you can give it a message (string) or a tuple
of messages (tuple of string)

```python
# The usual case
raise Exception("an error occurred")

# With multiple arguments
raise Exception("an error occurred", "unexpected value", 42)
```

`.__tracback__` contains a `traceback object`

> A [traceback](https://realpython.com/python-traceback/) object is also call a Stack
  trace, Stack traceback, and backtrace
> Exceptions have more than sixty dunder attributes.

#### Link to documentation for different exception types

|:warning:|:boom:|:interrobang:|
|--|--|--|
|[Warning](https://docs.python.org/3/library/warnings.html#warning-categories)|[Error](https://docs.python.org/3/library/exceptions.html#concrete-exceptions)|[Exception](https://docs.python.org/3/library/exceptions.html#Exception)|

### Different ways of handling an Exception

#### 3 Steps to Handle Exception

1. **Predict what exceptions can happen**. You can even fail the program voluntarily
to discover what exceptions are raised.
1. If **custom exception**, use the raise keyword.
1. **Determine where the exception needs to be handled in your code.**

#### Handling Exception Example

Basic handling of error.

```python
colors = ["red", "blue", "green"]

try:
    colors[10]
except IndexError:
    print("your list doesn't have that index :-(")
```

You can also handle multiple errors in the same except statement.

```python
colors = ["red", "blue", "green"]

try:
  colors[10]
except (ValueError, IndexError) as error:
  if isinstance(ValueError, error):
    print("this error is a value error")

  if isinstance(IndexError, error):
    print("this is an index error")
```

When handling you might want to do extra computing before raising the error.

```python
>>> import logging
>>> try:
...     result = 42 / 0
... except Exception as error:
...     logging.error(error)
...     raise

ERROR:root:division by zero
Traceback (most recent call last):
  File "<stdin>", line 5, in <module> # will only appear if 'raise error' was called
  File "<stdin>", line 2, in <module>
ZeroDivisionError: division by zero
```

### Different ways of raising an Exception

#### The `raise` keyword

> In Python, exceptions are raised, while in other languages like Java and C++,
exceptions are thrown

```python
# ...
raise [expression [from another_expression]]
# ...
```

> The `from` clause is optional.

:warning: A `raise` keyword with no argument and no exception raised beforehand will
lead to a RuntimeError exception since no exceptions are raised or reraised

The `raise` keyword can take any expression that returns an exception class or instance

```python
# From a function returning an exception
def exception_factory(exception, message):
  return exception(message)

raise exception_factory(ValueErrpr, "invalid value")

# From a class instantiation
class MyException(Exception)
  pass

raise MyException("an eror occurred")
```

|:warning:|Raising direct instance of `Exception` is not considered best practice|
|--|--|
|:white_check_mark:|Always raise custom or built-in exceptions|

#### Raising Custom Exception Example

```python
# grades .py

# Creating our custom exception
class GradeValueError(Exception):
  pass

def calculate_avergae_grade(grades):
  total = 0
  count = 0
  for grade in grades:
    if grade < 0 or grade > 100:
      # Raise our custom exception
      raise GradeValueError(
        "grade values must be between 0 and 100 inclusive"
      )
    total += grade
    count += 1
  return round(total / count, 2)
```

> We could have used ValueError, but GradeValueError is more specific and best describe
the error.

You should raise an exception to:

- Signal errors and exceptional situations
- Reraise exception after doing some additional processing (Example: logging)

> Python encourages the **Easier to ask forgiveness than permission (EAFP)** over
**Look before you lead (LBYL)**.

|:bookmark_tabs:| It's up to the developer to decide when to handle the exception.|
|:--|:--|

#### Different `raise` keyword situation

##### Alone

```python
def some_func(arg):
    try:
        do_something(arg)
    except Exception as error:
        logging.error(error)
        raise
    # Here raise will reraise the Exception that was raised by do_something
```

##### Conditionally

```python
>>> from math import sqrt

>>> def is_prime(number):
...     if not isinstance(number, int):
...         raise TypeError(
...             f"integer number expected, got {type(number).__name__}"
...         )
...     if number < 2:
...         raise ValueError(f"integer above 1 expected, got {number}")
...     for candidate in range(2, int(sqrt(number)) + 1):
...         if number % candidate == 0:
...             return False
...     return True
...
```

:white_check_mark: Raising exceptions early, before doing any computation, is considered
best practice.

##### Wrap Exception into another one

```python
>>> class MathLibraryError(Exception):
...     pass
...

>>> def divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError as error:
...         raise MathLibraryError(error)
...

>>> divide(1, 0)
Traceback (most recent call last):
  File "<stdin>", line 3, in divide
ZeroDivisionError: division by zero

During the handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in divide
MathLibraryError: division by zero
```

:exclamation: Even if the above can greatly improve your code, the `from` syntax
offers better alternatives.

#### Using the `from` clause

The optional clause `from` allows the developers to chain another exception
to the active one.

If the argument passed to `from` is an instance of an exception, it will directly
attach itself to the dunder attribute `.__cause__`, if it's an exception class,
Python will instantiate it before attaching it to `.__cause__`.

When using `from`, you can expect both exception tracebacks on the screen.

```python
>>> try:
...     result = 42 / 0
... except Exception as error:
...     raise ValueError("operation not allowed") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: operation not allowed
```

In this example, Python indicates that the first error (`ZeroDivisionError`) is the
reason for the second error (`ValueError`). It is very useful when writing code that
can raise multiple types of exceptions. For example:

```python
>>> def divide(x, y):
...     for arg in (x, y):
...         if not isinstance(arg, int | float):
...             raise TypeError(
...                 f"number expected, got {type(arg).__name__}"
...             )
...     if y == 0:
...         raise ValueError("denominator can't be zero")
...     return x / y
...
```

The divide function here raises different types of error: `TypeError` and
`ValueError`. Here's how it will behave with the `from` clause for `raise`:

```python
>>> try:
...     divide(42, 0)
... except Exception as error:
...     raise ValueError("invalid argument") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 6, in divide
ValueError: denominator can't be zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: invalid argument

>>> try:
...     divide("One", 42)
... except Exception as error:
...     raise ValueError("invalid argument") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 4, in divide
TypeError: number expected, got str

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: invalid argument
```

> Without `from`, the traceback does not indicate a direct link between the errors.

- With `from`:
  - The above exception was the direct cause of the following exception
- Without `from`:
  - During handling of the above exception, another exception occurred

##### With None

You want to use the argument `None` with `from` when you want to suppress
built-in traceback from custom error or when the original traceback is not
necessary or informative. A use case is a package to consume an external REST
API where you don't want to expose the `requests` library (or `urllib3` library)
exception.

```python
>>> import requests

>>> class APIError(Exception):
...     pass
...

>>> def call_external_api(url):
...     try:
...         response = requests.get(url)
...         response.raise_for_status()
...         data = response.json()
...     except requests.RequestException as error:
...         raise APIError(f"{error}") from None
...     return data
...

>>> call_external_api("https://api.github.com/events")
[
    {
        'id': '29376567903',
        'type': 'PushEvent',
    ...
]

>>> # No error happened

>>> call_external_api("https://api.github.com/event")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 7, in call_external_api
__main__.APIError: 404 Client Error: Not Found for url:
  https://api.github.com/event

>>> # An error happened
```

With this example, you can see that the original exception
(`requests.RequestException`) was absent from the traceback.

### Good practice when handling/raising Exceptions

|:warning:| Catching generic `Exception` is considered bad practice.|
|--:|:--|
|:exclamation:|Doing so could result in critical errors not being found.|

- **Favor specific exceptions over generic ones**
- **Provide informative error messages and avoid exceptions with no message**
- **Favor built-in exceptions over custom exceptions**
- **Avoid raising the `AssertionError` Exception**
- **Raise Exception as soon as possible**
- **Explain the raised exceptions in your code's documentation**

> `AssertionError` are raised only in tests, that's why they should not be raised
manually in your code.

#### Error message writing convention

When writing an error message follow these rules:

- Message start with a lowercase letter and don't end with a period
- Error message should clearly and concisely describe what is the issue that caused
the exception to be raised.
- Remember that the message needs to be specific enough to help the developer in
in the debugging process.

|:warning:|Error Message|
|--|:--|
|:x:|"Invalid age."|
|:white_check_mark:|"age must not be negative"|

#### Creating Custom Exception Convention

|:warning:| Convention to follow while creating custom exception|
|:--|--|
|:point_right:| naming convention for class ([CapWords convention](https://peps.python.org/pep-0008/#class-names))|
|:point_right:| Add the suffix `Error` when representing an error|
|:point_right:| Don't add suffix for non-error exceptions|
|:point_right:| Add the `Warning` suffix when defining custom warning|

#### Document

It is considered best practice to list and document all the exceptions your code
can raise with a brief description of how the users can handle them.

## Python: Gérer et soulever des exceptions

### Avant de commencer

- [English version](#before-starting) :small_orange_diamond:
- Cet entraînement est pour les développeurs backend, mais tous sont les
  bienvenus.

### Qu'est-ce qu'une Exception

Une exception en Python indique qu’il y a eu un problème dans votre code. Elle
peut prendre la forme d’une erreur (cas classique), d’un avertissement ou d’une
situation exceptionnelle.

> :grey_exclamation: Notez que toutes les exceptions en Python ne sont pas des erreurs.
Le meilleur exemple est l’objet [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration),
qui est une sous-classe de `Exception`

Lorsqu'une `Exception` représente une erreur, il est courant d'ajouter le suffixe
`Error` à son nom. Exemple :

- `ValueError`, `DivisionByZeroError`, etc.

Lorsqu'une `Exception` représente un avertissement, Python propose la classe `Warning`
pour signaler des conditions qui ne nécessitent pas l'arrêt du programme.

Il existe deux types d'exceptions en Python :

- Exceptions intégrées : Ces exceptions sont intégrées dans le langage.
- Exceptions définies par l'utilisateur : Des exceptions personnalisées définies
par les développeurs. Elles se trouvent généralement dans un module spécifique
pour un projet donné.

> Vous pouvez trouver la hiérarchie des exceptions intégrées [ici](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

#### Création d'exception définie par l'utilisateur exemple

```python
# Toujours utiliser la classe Exception
# Ne pas utiliser la classe BaseException
class MyException(Exception):
    pass

# Pour des exemples, voir les liens des exceptions
class MyExceptionError(Exception):
    pass

# UserWarning est la classe pour générer des avertissements
# Warning est la classe de base pour tous les avertissements
class MyWarning(UserWarning):
    pass
```

> En Python, il est courant de créer une classe fictive pour les exceptions en utilisant
le mot-clé `pass`, car le nom de la classe est l’élément le plus important.

|:warning:|Un bon nom d’exception personnalisée communique le problème sous-jacent|
|--|:--|
|:x:| GenericException(Exception)|
|:white_check_mark:| SpecificToProjectException(Exception)|

Voici une liste des attributs principaux des exceptions :

|Attributs|Type|Actions|
|--|--|--|
|`args`|tuple or string|Contiens toutes les valeurs passées en argument à la classe|
|`__traceback__`|dunder attribute|Contiens l'object traceback de l'exception|
|`__cause__`|dunder attribute|Contiens l'expression passée au mot-clé `from`|
|`.with_traceback()`|methodes|Mets à jour l'objet traceback de l'exception|
|`.add_notes()`|methodes|Ajoute des notes à l'objet traceback (`__note__`)|

Quand vous instanciez une exception, vous pouvez lui donner un ou plusieurs attributs.

```python
# L'instanciation habituelle
raise Exception("an error occurred")

# Avec plusieurs arguments
raise Exception("an error occurred", "unexpected value", 42)
```

> Un objet [traceback](https://realpython.com/python-traceback/) est aussi appelé
 un Stack trace, un Stack traceback et un backtrace
> Les exceptions comptent plus de 60 attributs.

#### Lien vers la documentation des différents types d'exception

|:warning:|:boom:|:interrobang:|
|--|--|--|
|[Warning](https://docs.python.org/3/library/warnings.html#warning-categories)|[Error](https://docs.python.org/3/library/exceptions.html#concrete-exceptions)|[Exception](https://docs.python.org/3/library/exceptions.html#Exception)|

### Différente façon de gérer une Exception

#### 3 étapes pour gérer les exceptions

1. **Prédire quelles exceptions peuvent se produire**. Vous pouvez même provoquer
volontairement l'échec du programme pour découvrir quelles exceptions sont levées.
1. Si vous utilisez une **exception personnalisée**, utilisez le mot-clé `raise`.
1. **Déterminez où l'exception doit être gérée dans votre code**.

#### Gérer les exceptions exemple

Gestion générique des exceptions.

```python
couleurs = ["rouge", "bleu", "vert"]

try:
    couleurs[10]
except IndexError:
    print("votre liste ne possède pas cet index :-(")
```

Vous pouvez aussi gérer plusieurs erreurs dans la même déclaration.

```python
couleurs = ["rouge", "bleu", "vert"]

try:
  couleurs[10]
except (ValueError, IndexError) as erreur:
  if isinstance(ValueError, erreur):
    print("cette erreur est une erreur de valeur")

  if isinstance(IndexError, error):
    print("cette erreur est une erreur d'index")
```

Lors de la gestion d'exception, vous voudrez peut-être effectuer des actions supplémentaires
avant de lever l’erreur.

```python
>>> import logging
>>> try:
...     result = 42 / 0
... except Exception as erreur:
...     logging.error(erreur)
...     raise

ERROR:root:division by zero
Traceback (most recent call last):
  File "<stdin>", line 5, in <module> # will only appear if 'raise error' was called
  File "<stdin>", line 2, in <module>
ZeroDivisionError: division by zero
```

### Différente façon de lever une Exception

```python
# grades.py

# Créer son exception personnalisée
class GradeValueError(Exception):
  pass

def calculate_avergae_grade(grades):
  total = 0
  count = 0
  for grade in grades:
    if grade < 0 or grade > 100:
      # Lever l'exception personnalisée
      raise GradeValueError(
        "grade values must be between 0 and 100 inclusive"
      )
    total += grade
    count += 1
  return round(total / count, 2)
```

> Ici on aurait pu utiliser ValueError, mais GradeValueError est plus spécifique
et décrit mieux l'erreur qu'on veut lancer.

Vous devriez lever une exception lorsque :

- Vous signalez des erreurs ou une situation exceptionnelle
- Vous soulevez de nouveau une exception après avoir fait d'autres opérations (par
exemple: du logging)

> Python encourage l'approche **Easier to ask forgiveness than permission (EAFP)**
plutôt que l'approche **Look before you lead (LBYL)**.

|:bookmark_tabs:|C'est au développeur de décider du bon moment pour gérer une exception.|
|:--|:--|

#### Utilisation du mot clé `raise`

##### Seul

```python
def some_func(arg):
    try:
        do_something(arg)
    except Exception as error:
        logging.error(error)
        raise
    # Ici on le mot clé "raise" soulève de nouveau l'Exception qui a été soulevée
    # par do_something
```

##### Conditionnelle

```python
>>> from math import sqrt

>>> def is_prime(number):
...     if not isinstance(number, int):
...         raise TypeError(
...             f"s'attend a un integer, reçoit {type(number).__name__}"
...         )
...     if number < 2:
...         raise ValueError(f"s'attend à un integer au-dessus de 1, reçoit {number}")
...     for candidate in range(2, int(sqrt(number)) + 1):
...         if number % candidate == 0:
...             return False
...     return True
...
```

:white_check_mark: Lever des exceptions rapidement, avant d'effectuer des opérations
importantes constitue une bonne pratique.

##### Envelopper des exceptions ensemble

```python
>>> class MathLibraryError(Exception):
...     pass
...

>>> def divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError as error:
...         raise MathLibraryError(error)
...

>>> divide(1, 0)
Traceback (most recent call last):
  File "<stdin>", line 3, in divide
ZeroDivisionError: division by zero

During the handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in divide
MathLibraryError: division by zero
```

:exclamation: Même si l'exemple ci-dessus peut vraiment améliorer votre code, la
clause `from` offre de meilleures alternatives.

#### Utilisation de la clause `from`

La clause optionnelle `from` permets au développeur d'associer une exception à celle
qui est active.

Si l'argument passé en paramètre à la clause `from` est une instance d'exception,
celle-ci va s'attacher à l'attribut `__cause__`. S'il s'agit d'une classe d'exception,
Python va l'instancier avant de l'attacher à l'attribut `__cause__`.

Lorsque la clause `from` est utilisée, vous pouvez vous attendre à avoir le traceback
des deux exceptions à la console.

```python
>>> try:
...     result = 42 / 0
... except Exception as error:
...     raise ValueError("opération non alloué") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: operation not allowed
```

Dans cet exemple, Python indique la première erreur (`ZeroDivisionError`) est la
raison de la seconde erreur (`ValuError`). Il s'agit d'un outil très efficace pour
écrire du code qui peut soulever plusieurs types d'exceptions. Par exemple :

```python
>>> def divide(x, y):
...     for arg in (x, y):
...         if not isinstance(arg, int | float):
...             raise TypeError(
...                 f"s'attend à recevoir un nombre, reçoit {type(arg).__name__}"
...             )
...     if y == 0:
...         raise ValueError("le dénominateur ne peut pas être zéro")
...     return x / y
...
```

La division fonctionne puisqu'on lève différentes erreurs : `TypeError` et `ValueError`.
Voici comment la fonction se comporte avec la clause `from` avec `raise` :

```python
>>> try:
...     divide(42, 0)
... except Exception as error:
...     raise ValueError("argument invalide") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 6, in divide
ValueError: denominator can't be zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: invalid argument

>>> try:
...     divide("Un", 42)
... except Exception as error:
...     raise ValueError("argument invalide") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 4, in divide
TypeError: number expected, got str

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: invalid argument
```

> Sans la clause `from`, le traceback ne va pas indiquer de lien direct entre les
deux erreurs.

- Avec `from`:
  - The above exception was the direct cause of the following exception

- Sans `from`:
  - During handling of the above exception, another exception occurred

##### Avec None

Vous voulez utiliser l'argument `None` avec `from` quand vous ne voulez pas afficher
le traceback `built-in` d'une erreur personnalisée ou encore lorsque le traceback
original n'est pas nécessaire ou informatif. Un bon exemple, c'est un module qui
utilise un REST API externe sans vouloir exposer les exceptions de la librairie
`requests` (ou `urllib3`).

```python
>>> import requests

>>> class APIError(Exception):
...     pass
...

>>> def call_external_api(url):
...     try:
...         response = requests.get(url)
...         response.raise_for_status()
...         data = response.json()
...     except requests.RequestException as error:
...         raise APIError(f"{error}") from None
...     return data
...

>>> call_external_api("https://api.github.com/events")
[
    {
        'id': '29376567903',
        'type': 'PushEvent',
    ...
]

>>> # Aucune erreur ne s'est produite

>>> call_external_api("https://api.github.com/event")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 7, in call_external_api
__main__.APIError: 404 Client Error: Not Found for url:
  https://api.github.com/event

>>> # Une erreur s'est produite
```

Avec cet exemple, on remarque que l'exception d'origine (`requests.RequestException`)
est absente du `traceback`.

### Les bonnes pratiques lorsqu'on lève / gère des Exceptions

|:warning:|Attraper une `Exception` générique est considéré comme une mauvaise pratique|
|--:|:--|
|:exclamation:|Ce comportement peut cacher des erreurs critiques.|

- **Favoriser les exceptions spécifiques avant les exceptions génériques**
- **Fournissez des messages d'erreur informatifs et évitez les exceptions sans message**
- **Privilégiez les exceptions intégrées aux exceptions personnalisées**
- **Évitez de lever l'exception `AssertionError`**
- **Levez l'exception dès que possible**
- **Expliquez les exceptions levées dans la documentation de votre code**

> Les `AssertionError` sont soulevés uniquement dans les tests, c'est pourquoi il
ne faut pas lever manuellement ce type d'erreur dans votre code.

#### Convention d'écriture des messages d'erreur

Suivre ces règles lorsque vous écrivez des messages d'erreurs :

- Les messages commencent par une lettre minuscule et se terminent sans point.
- Le message d'erreur doit décrire clairement et succinctement la cause de l'exception.
- N'oubliez pas que le message doit être suffisamment spécifique pour aider le développeur
dans le processus de débogage.

|:warning:|Message d'erreur|
|--|:--|
|:x:|"Âge invalide."|
|:white_check_mark:|"l'âge ne peut pas être négatif"|

#### Convention pour la création d'exception personnalisée

|:warning:| Convention à suivre lors de la création d'exception personnalisée|
|:--|--|
|:point_right:|Convention de nommage pour les classes ([CapWords convention](https://peps.python.org/pep-0008/#class-names))|
|:point_right:|Ajouter le suffixe `Error` quand vous représentez une erreur|
|:point_right:|Ne pas ajouter le suffixe lorsque l'exception n'est pas une erreur|
|:point_right:|Ajouter le suffixe `Warning` lorsque vous déclarez des avertissements|

#### Documenter

Il est considéré comme une bonne pratique de répertorier et de documenter toutes
les exceptions que votre code peut générer, avec une brève description et des
indications sur la manière dont les utilisateurs peuvent les gérer.

[Revenir en haut](#python-gérer-et-soulever-des-exceptions)

## Annexe 1

### ExceptionGroup

A ExceptionGroup is a subclass of Exception that use the `except*` syntaxe. The
traceback will have a different syntax.

Une exception de group ou `ExceptionGroup` est une sous-classe d'`Exception` qui
utilise la syntaxe `except*`. L'objet traceback sera alors différent.

```python
>>> raise ExceptionGroup(
...  "several errors",
...  [
...    ValueError("invalid value"),
...    TypeError("invalid type"),
...    KeyError("missing key")
...  ]
... )
...
  + Exception Group Traceback (most recent call last):
  |   File "<stdin>", line 1, in <module>
  | ExceptionGroup: several errors (3 sub-exceptions)
  +-+---------------- 1 ----------------
    | ValueError: invalid value
    +---------------- 2 ----------------
    | TypeError: invalid type
    +---------------- 3 ----------------
    | KeyError: 'missing key'
    +------------------------------------
```

When catching ExceptionGroup, you can use the `except*` syntaxe...

Lorsque vous attrapez des `ExceptionGroup`, vous pouvez utiliser la syntaxe `except*`...

```python
>>> try:
...     raise ExceptionGroup(
...         "several errors",
...         [
...             ValueError("invalid value"),
...             TypeError("invalid type"),
...             KeyError("missing key"),
...         ]
...     )
... except* ValueError:
...     print("Handling ValueError")
... except* TypeError:
...     print("Handling TypeError")
... except* KeyError:
...     print("Handling KeyError")
...
Handling ValueError
Handling TypeError
Handling KeyError
```

... or catch them like any other exception.

... ou l'attraper comme une autre exception.

```python
>>> try:
...     raise ExceptionGroup(
...         "several errors",
...         [
...             ValueError("invalid value"),
...             TypeError("invalid type"),
...             KeyError("missing key"),
...         ]
...     )
... except ExceptionGroup:
...     print("Got an exception group!")
...
Got an exception group!
```
