# Python: Handling and Raising Exception / G√©rer et soulever des erreurs

## Before starting

üöß
This files is not intended to be push to the main branch of dev-rel-docs. It's just to give a chance for everyone to review the note I took
üöß


- [Version Fran√ßaise](#avant-de-commencer) :small_blue_diamond:
- This training is aimed at the backend developer, but everybody is welcome to read it.

|:wave: To know more|
|:--|
|[Pozo Ramos, L. (2023,19 juin). *Python's raise: Effectively Raising Exceptions in Your Code*. Real Python](https://realpython.com/python-raise-exception/#chaining-exceptions-with-the-from-clause)|

### Handling Exceptional Situations in Python

> Not all exceptions in Python are errors. Example: The built-in [StopIteration](https://docs.python.org/3/library/exceptions.html#StopIteration)

Python errors have the `Error` suffix. The language also has a class for warning; `Warning` to raise a flag on a condition that doesn't need to terminate the program.

```python
# Always use Exception for your code
# Do not use Base Exception
class MyException(Exception):
    pass

# For examples see error link
class MyExceptionError(Exception):
    pass

# UserWarning is for warning generated by user code
# Warning is the base class for warning categories
class MyWarning(UserWarning):
    pass

```

#### Link to documentation for different exception types

|:warning:|:collision:|:interrobang:|
|--|--|--|
|[Warning](https://docs.python.org/3/library/warnings.html#warning-categories)|[Error](https://docs.python.org/3/library/exceptions.html#concrete-exceptions)|[Exception](https://docs.python.org/3/library/exceptions.html#Exception)|

Every exception have a [traceback](https://realpython.com/python-traceback/) attribute, also name:

- Stack trace,
- Stack traceback
- backtrace

#### How to handle exceptions

```python
colors = ["red", "blue", "green"]

# Basic handling of error

try:
    colors[10]
except: IndexError:
    print("Your list doesn't have that index :-(")
```

##### Steps to handle exceptions

1. Predict what exceptions can happen, sometimes you might want to fail the program to discover what exceptions are raised.
1. If custom exception, use the raise keyword
1. Determine where the exception needs to be handled in your code

### Raising Exceptions in Python: The `raise` Statement

> In Python, exceptions are raised, while in other languages like Java and C++, exceptions are thrown.

```python
# ...
raise [expression [from another_expression]]
#...
```

|:warning:| A `raise` keyword with no argument and no exception raised beforehand will lead to a RuntimeError exception since no exceptions are raised or reraised.|
|:--:|:--|

> The `raise` keyword can take any expression that returns an exception class or instance.

```python

# From a function returning an exception
def exception_factory(exception, message):
    return exception(message)

raise exception_factory(ValueError, "invalid value")

# From a class instantiation
class MyException(Exception)
    pass

raise MyException("an error occurred")
```

> The `from` clause is optional. It allows the developers to chain exceptions together.

|:warning:| Raising `Exception` instance is not considered best practice.|
|--|:--|
|:white_check_mark:| Always raise custom or built-in exceptions.|

#### Error message writing convention

|:warning:| In Python, it is considered common practice that error messages start with a lowercase letter and don't end with a period|
|--|:--|
|:x:| "An error occurred here."|
|:white_check_mark:| "an error occurred here"|

Maintaining this pattern will help ensure consistency in the codebase.

#### Exception arguments

Typically, a developer will instantiate an `Exception` class with only one argument, but on certain occasions (for example, to provide more context to the error), the `Exception` can take more than one argument.

```python
# The usual case
raise Exception("an error occurred")

# With multiple arguments
raise Exception("an error occurred", "unexpected value", 42)
```

If the `Exception` constructor receives more than one argument, it will store them in a tuple that can be accessed through the args variable.

```python
>>> error = Exception("an error occurred", "unexpected value", 42)
>>> error.args
('an error occurred, 'unexpected value', 42)
>>> error.args[1]
'unexpected value'
```

Exception classes also have two methods:

|methods | actions|
|--|--|
|exception.with_traceback() | allows the developer to give a new trackback to the exception. Return the updated exception object|
|exception.add_notes() | allows the developer to add notes to the exception traceback. Those note can be access with the `.__notes__` dunder (or specials) attribute|

> These functions help provide more context to the other developer

Exceptions also have lots of dunder attributes. The useful ones are `.__traceback__` and `.__cause__`.

|dunder attribute | actions|
|--|--|
|`.__traceback__` | hold the traceback object of the exception|
|`.__cause__` | store the expression passed to the `from` class when chaining exceptions|


### Choosing the Exception to Raise: built-in vs Custom

#### Two kinds of exceptions

- Built-in exceptions: Those exceptions are built into the language. Importation is not needed for their usage.
- User-defined exceptions: Custom exceptions defined by the developers. They are typically in a module for a specific project.

> You can find the built-in exception hierarchy [here](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)

#### Raising built-in error

```python
>>> # Raise a built-in type error
>>> def squared(numbers):
...    if not isinstance(numbers, list | tuple):
...        raise TypeError(
...            f"list or tuple expected, got '{type(numbers).__name__}'")
...        return [number**2 for number in numbers]
...

>>> squared([1,2,3,4,5])
[1,4,9,15,25]

>>> squared({1,2,3,4,5})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in squared
TypeError: list or tuple expected, got 'set'
```

#### Coding and Raising Custom Exception

Python has more than sixty built-in exceptions. If none of them suit the developer's needs, then the developer can define a custom one. The next example is a use case for a grade book.

```python
# grades.py

# Creating our custom exception
class GradeValueError(Exception):
    pass

def calculate_average_grade(grades):
    total = 0
    count = 0
    for grade in grades:
        if grade < 0 or grade > 100:
            # Raise our custom exception
            raise GradeValueError(
                "grade values must be between 0 and 100 inclusive
            )
        total += grade
        count += 1
    return round (total / count, 2)
```

> In Python, it is common practice to create a placeholder class for exceptions with the keyword `pass` as the most important feature of the class is its name.

|:warning:| In Python, a custom exception name needs to communicate the underlying issue|
|--|:--|
|:x:| GenericException(Exception)|
|:white_check_mark:| SpecificToProjectException(Exception)|

> For example, GradeValueError is better at explaining what is the error than the built-in ValueError.

|:warning:| Convention to follow while creating custom exception|
|:--|--|
|:point_right:| naming convention for class ([CapWords convention](https://peps.python.org/pep-0008/#class-names))|
|:point_right:| Add the suffix `Error` when representing an error|
|:point_right:| Don't add suffix for non-error exceptions|
|:point_right:| Add the `Warning` suffix when defining custom warning|

> These conversations help other developers understand your intention.

### Deciding When to Raise Exceptions

You should raise an exception to:

- **Signal errors and exceptional situations**
- **Reraise exception after doing some additional processing**: For example, when you need to log the error before raising the exception

Python encourages its developers to use exceptions when dealing with errors and exceptional situations. The way to do it is with a `try ... except` construct. You can find a lot of examples in the standard library and the language itself.

```python
def some_func(arg):
    try:
        do_something(arg)
    except Exception as error:
        logging.error(error)
        raise
    # Here raise will reraise the Exception that was raised by doing something
```

> **Look before you lead (LBYL)** is an approach that encourages developers to use error codes and conditionals
**Easier to ask forgiveness than permission (EAFP)** is the approach that encourages developers to raise and handle exceptions.

|:bookmark_tabs:| It's up to the developer to decide when to handle the exception.|
|:--|:--|

### Raising Exception Conditionally

Raising exceptions when meeting a given condition is related to possible errors and exceptional situations. Example: you write a function to validate if a number is a prime number. The number the function accepts needs to be bigger than two and an integer.

```python
>>> from math import sqrt

>>> def is_prime(number):
...     if not isinstance(number, int):
...         raise TypeError(
...             f"integer number expected, got {type(number).__name__}"
...         )
...     if number < 2:
...         raise ValueError(f"integer above 1 expected, got {number}")
...     for candidate in range(2, int(sqrt(number)) + 1):
...         if number % candidate == 0:
...             return False
...     return True
...
```

|:white_check_mark:| Raising exceptions early, like in this example where errors are raised before doing any computation, is considered best practice.|
|--|:--|

### Reraising a Previous Exception

The first use case is using the `raise` keyword without any argument.

```python
>>> import logging

>>> try:
...     result = 42 / 0
... except Exception as error:
...    logging.error(error)
...    # Reraise the exception with raise without argument
...    raise
...    # Using 'raise error' will give the same result

ERROR:root:division by zero
Traceback (most recent call last):
  File "<stdin>", line 5, in <module> # will only appear if 'raise error' was called
  File "<stdin>", line 2, in <module>
ZeroDivisionError: division by zero
```

|:warning:| Catching generic `Exception` is considered bad practice. Doing so could result in critical error not being found|
|--|:--|

Another use case is when you want to wrap one exception in another or intercept and translate the exception into a different one.

Example: building a math library and catching math errors to wrap them in a MathLibraryError class.

```python
>>> class MathLibraryError(Exception):
...     pass
...

>>> def divide(a, b):
...     try:
...         return a / b
...     except ZeroDivisionError as error:
...         raise MathLibraryError(error)
...

>>> divide(1, 0)
Traceback (most recent call last):
  File "<stdin>", line 3, in divide
ZeroDivisionError: division by zero

During the handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in divide
MathLibraryError: division by zero
```

In this example, we catch the `ZeroDivisionError` and wrap it in the `MathLibraryError`. It is useful in situations like:

- **Abstracting away external exceptions**: Useful when writing a library and the developer doesn't want their user to handle the external exceptions. In this example, a user of the `MathLibrary` will only need to be aware of MathLibraryError instead of all the math errors that can happen.
- **Unifying handling actions**: Useful to handle different exceptions that would be handled the same way. Useful to simplify error-handling logic.
- **Augmenting the context of a caught exception**: When the error or exception lacks context, you can add it and then reraise the exception.

|:exclamation:| Even if the above can greatly improve your code, the `from` syntax often offers better alternatives.|
|--|:--|

### Chaining Exceptions With the `from` Clause

The optional clause `from` allows the developer to chain another exception to the active one.

If the argument to `from` is an instance of an exception, it will directly attach itself to the dunder `.__cause__`, if it's an exception class, Python will instantiate it before attaching it to `.__cause__`.

When using `from`, you can expect to have both exception tracebacks on the screen.

```python
>>> try:
...     result = 42 / 0
... except Exception as error:
...     raise ValueError("operation not allowed") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: operation not allowed
```

In this example, Python will directly indicate that the first error (`ZeroDivisionError`) is the reason for the second error (`ValueError`). It is very useful when writing code that can raise multiple types of exceptions. For example:

```python
>>> def divide(x, y):
...     for arg in (x, y):
...         if not isinstance(arg, int | float):
...             raise TypeError(
...                 f"number expected, got {type(arg).__name__}"
...             )
...     if y == 0:
...         raise ValueError("denominator can't be zero")
...     return x / y
...
```

The divide function here raises different types of error: `TypeError` and `ValueError`. Here's how it will behave with the `from` clause for `raise`:

```python
>>> try:
...     divide(42, 0)
... except Exception as error:
...     raise ValueError("invalid argument") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 6, in divide
ValueError: denominator can't be zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: invalid argument

>>> try:
...     divide("One", 42)
... except Exception as error:
...     raise ValueError("invalid argument") from error
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
  File "<stdin>", line 4, in divide
TypeError: number expected, got str

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
ValueError: invalid argument
```

> If your note using from the message will be different. Without `from`, the traceback indicates a direct link between the two errors.

|With `from` | Without `from`|
|:--|:--|
|The above exception was the direct cause of the following exception | During handling of the above exception, another exception occurred|

#### Using `from` with `None`

You want to use the argument `None` with `from` when you want to suppress built-in traceback from custom error or when the original traceback is not necessary or informative. A use case is a package to consume an external REST API where you don't want to expose the `requests` library (or `urllib3` library) exception.

```python
>>> import requests

>>> class APIError(Exception):
...     pass
...

>>> def call_external_api(url):
...     try:
...         response = requests.get(url)
...         response.raise_for_status()
...         data = response.json()
...     except requests.RequestException as error:
...         raise APIError(f"{error}") from None
...     return data
...

>>> call_external_api("https://api.github.com/events")
[
    {
        'id': '29376567903',
        'type': 'PushEvent',
    ...
]

>>> # No error happened

>>> call_external_api("https://api.github.com/event")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 7, in call_external_api
__main__.APIError: 404 Client Error: Not Found for url:
  https://api.github.com/event

>>> # An error happened
```

With this example, you can see that the original exception (`requests.RequestException`) was absent from the traceback.

### Following Best Practices When Raising Exceptions

- **Favor specific exceptions over generic ones**
- **Provide informative error messages and avoid exceptions with no message**
- **Favor built-in exceptions over custom exceptions**
- **Avoid raising the `AssertionError` Exception**
- **Raise Exception as soon as possible**
- **Explain the raised exceptions in your code's documentation**

|:bookmark_tabs:|For more details see [Following Best Practices When Raising Exceptions](https://realpython.com/python-raise-exception/#following-best-practices-when-raising-exceptions)|
|--|--|

#### Error Message

|:warning:| Error message should clearly and concisely describe what is the issue that caused the exception to be raised. Remember that the message needs to be specific enough to help the developer in the debugging process.|
|--|:--|
|:x:|"invalid age"|
|:white_check_mark:|"age must not be negative"|

#### Document :exclamation:

It is considered best practice to list and document all the exceptions your code can raise with a brief description and how the users can handle them.

### Raising Exceptions and the `assert` Statement

The `assert` statement can also raise exceptions. Only, unlike raise, the only exception it can raise is the `AssertionError` type. It is mostly a debugging and testing tool.

### Raising Exception Groups

|:exclamation:| New since Python 3.11|
|--|--|

Raising Exception Groups can be useful when dealing with asynchronous programs that process multiple concurrent tasks that may fail at the same time. In general, it is not often used by developers.

#### Raising an ExceptionGroup

```python
>>> raise ExceptionGroup(
...     "several errors",
...     [
...         ValueError("invalid value"),
...         TypeError("invalid type"),
...         KeyError("missing key"),
...     ],
... )
  + Exception Group Traceback (most recent call last):
  |   File "<stdin>", line 1, in <module>
  | ExceptionGroup: several errors (3 sub-exceptions)
  +-+---------------- 1 ----------------
    | ValueError: invalid value
    +---------------- 2 ----------------
    | TypeError: invalid type
    +---------------- 3 ----------------
    | KeyError: 'missing key'
    +------------------------------------
```

`ExceptionGroup` is raised the same as any other exception. However, since the group contains multiple exceptions, the traceback will be different as shown by the previous example. You can then catch them as portraits in the example below.

```python
>>> try:
...     raise ExceptionGroup(
...         "several errors",
...         [
...             ValueError("invalid value"),
...             TypeError("invalid type"),
...             KeyError("missing key"),
...         ],
...     )
... except* ValueError:
...     print("Handling ValueError")
... except* TypeError:
...     print("Handling TypeError")
... except* KeyError:
...     print("Handling KeyError")
...
Handling ValueError
Handling TypeError
Handling KeyError
```

> Note that this syntax does not behave the same way as catching different exceptions, this will catch all of the exceptions that were raised. If you don't include the `*`, it will lead to no exception being caught. But you still can catch the `ExceptionGroup` as a whole since it's a subclass of `Exception`.

```python
>>> try:
...     raise ExceptionGroup(
...         "several errors",
...         [
...             ValueError("invalid value"),
...             TypeError("invalid type"),
...             KeyError("missing key"),
...         ],
...     )
... except ExceptionGroup:
...     print("Got an exception group!")
...
Got an exception group!
```

In this context, Python will catch the `ExceptionGroup` as any other `Exception` and run the handling code.

### Conclusion

|More on Exception|
|--|
|[Take the test](https://realpython.com/quizzes/python-raise-exception/)|
|[How to Catch Multiple Exceptions in Python](https://realpython.com/python-catch-multiple-exceptions/)|
|[Ever Better Error Messages](https://realpython.com/python312-error-messages/)|
|[LBYL vs EAFP: Preventing or Handling Errors in Python](https://realpython.com/python-lbyl-vs-eafp/)|

---

## Avant de commencer

- [English version](#before-starting) :small_orange_diamond:
- Cet entra√Ænement est pour les d√©veloppeurs backend, mais tous sont les bienvenues.

|:wave: Pour en savoir plus (anglais seulement)|
|:--|
|[Pozo Ramos, L. (2023,19 juin). *Python's raise: Effectively Raising Exceptions in Your Code*. Real Python](https://realpython.com/python-raise-exception/#chaining-exceptions-with-the-from-clause)|
